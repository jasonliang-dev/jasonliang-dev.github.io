const canvas=document.getElementById("canvas"),gl=canvas.getContext("webgl"),vec3={normalize(t){const e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return t[0]/=e,t[1]/=e,t[2]/=e,t}},mat4={pool:Array.from({length:64}).map((()=>new Float32Array(16))),poolIndex:0,alloc(){if(mat4.poolIndex!==mat4.pool.length)return mat4.pool[mat4.poolIndex++];console.error("matrix pool exhausted")},flush(){mat4.poolIndex=0},identity(){const t=mat4.alloc();return t.fill(0),t[0]=t[5]=t[10]=t[15]=1,t},multiply(t,e){const a=t[0],r=t[1],o=t[2],n=t[3],i=t[4],l=t[5],s=t[6],c=t[7],m=t[8],g=t[9],u=t[10],f=t[11],_=t[12],d=t[13],h=t[14],v=t[15],A=e[0],p=e[1],E=e[2],L=e[3],w=e[4],I=e[5],S=e[6],R=e[7],x=e[8],b=e[9],F=e[10],T=e[11],y=e[12],P=e[13],M=e[14],O=e[15],U=mat4.alloc();return U[0]=a*A+r*w+o*x+n*y,U[1]=a*p+r*I+o*b+n*P,U[2]=a*E+r*S+o*F+n*M,U[3]=a*L+r*R+o*T+n*O,U[4]=i*A+l*w+s*x+c*y,U[5]=i*p+l*I+s*b+c*P,U[6]=i*E+l*S+s*F+c*M,U[7]=i*L+l*R+s*T+c*O,U[8]=m*A+g*w+u*x+f*y,U[9]=m*p+g*I+u*b+f*P,U[10]=m*E+g*S+u*F+f*M,U[11]=m*L+g*R+u*T+f*O,U[12]=_*A+d*w+h*x+v*y,U[13]=_*p+d*I+h*b+v*P,U[14]=_*E+d*S+h*F+v*M,U[15]=_*L+d*R+h*T+v*O,U},translate(t,e,a){const r=mat4.identity();return r[12]=t,r[13]=e,r[14]=a,r},scale(t,e,a){const r=mat4.identity();return r[0]=t,r[5]=e,r[10]=a,r},rotate(t,e){const a=mat4.alloc(),[r,o,n]=t,i=Math.sin(e),l=Math.cos(e),s=1-l;return a[0]=r*r*s+l,a[1]=o*r*s+n*i,a[2]=n*r*s-o*i,a[3]=0,a[4]=r*o*s-n*i,a[5]=o*o*s+l,a[6]=n*o*s+r*i,a[7]=0,a[8]=r*n*s+o*i,a[9]=o*n*s-r*i,a[10]=n*n*s+l,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,a},perspective(t,e,a,r){const o=mat4.alloc();return o.fill(0),o[5]=1/Math.tan(.5*t),o[0]=o[5]/e,o[11]=-1,o[10]=-1,o[14]=-2*a,o}},gfx={compileShader(t,e){const a=gl.createShader(t);if(gl.shaderSource(a,e),gl.compileShader(a),!gl.getShaderParameter(a,gl.COMPILE_STATUS))throw"GL: "+gl.getShaderInfoLog(a);return a},createShaderProgram(t,e){const a=gfx.compileShader(gl.VERTEX_SHADER,t),r=gfx.compileShader(gl.FRAGMENT_SHADER,e),o=gl.createProgram();if(gl.attachShader(o,a),gl.attachShader(o,r),gl.linkProgram(o),!gl.getProgramParameter(o,gl.LINK_STATUS))throw"GL: "+gl.getProgramInfoLog(o);return o},checkForError(){const t=gl.getError();if(t!==gl.NO_ERROR)switch(t){case gl.INVALID_ENUM:throw"GL: INVALID_ENUM";case gl.INVALID_VALUE:throw"GL: INVALID_VALUE";case gl.INVALID_OPERATION:throw"GL: INVALID_OPERATION";case gl.INVALID_FRAMEBUFFER_OPERATION:throw"GL: INVALID_FRAMEBUFFER_OPERATION";case gl.OUT_OF_MEMORY:throw"GL: OUT_OF_MEMORY";case gl.CONTEXT_LOST_WEBGL:throw"GL: CONTEXT_LOST_WEBGL"}},createBuffer(t,e,a){const r=gl.createBuffer();return gl.bindBuffer(gl.ARRAY_BUFFER,r),gl.bufferData(gl.ARRAY_BUFFER,a,gl.STATIC_DRAW),gl.enableVertexAttribArray(e),gl.vertexAttribPointer(e,t,gl.FLOAT,!1,0,0),r}},state={};function init(){state.program=gfx.createShaderProgram("\n    #version 100\n\n    attribute vec3 a_position;\n    attribute vec3 a_normal;\n\n    varying vec3 v_modelPosition;\n    varying vec3 v_normal;\n\n    uniform mat4 u_model;\n    uniform mat4 u_view;\n    uniform mat4 u_projection;\n\n    void main() {\n      v_modelPosition = vec3(u_model * vec4(a_position, 1));\n      v_normal = vec3(u_model * vec4(a_normal, 0));\n      gl_Position = u_projection * u_view * u_model * vec4(a_position, 1);\n    }\n  ","\n    #version 100\n    precision mediump float;\n\n    varying vec3 v_modelPosition;\n    varying vec3 v_normal;\n\n    uniform vec4 u_color;\n    uniform float u_ambientStrength;\n    uniform float u_diffuseStrength;\n\n    void main() {\n      vec3 lightPos = vec3(-1, 0, 8);\n      vec3 lightColor = vec3(1, 1, 1);\n\n      vec3 lightDir = normalize(lightPos - v_modelPosition);\n      vec3 norm = normalize(v_normal);\n\n      vec3 ambient = u_ambientStrength * lightColor;\n\n      float diff = max(dot(norm, lightDir), 0.0);\n      vec3 diffuse = diff * lightColor * u_diffuseStrength;\n\n      vec3 result = ambient + diffuse;\n      gl_FragColor = vec4(result, 1) * u_color;\n    }\n  "),state.vertices=gfx.createBuffer(3,gl.getAttribLocation(state.program,"a_position"),new Float32Array([-.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,-.5,.5,.5,.5,.5,.5,.5,.5,-.5,.5,-.5,-.5,.5,-.5,-.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,-.5,.5,-.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,.5,-.5,.5,.5,-.5,.5,.5,.5,.5,.5,.5,-.5,.5,.5,-.5,.5,-.5])),state.normals=gfx.createBuffer(3,gl.getAttribLocation(state.program,"a_normal"),new Float32Array([0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0])),state.u_model=gl.getUniformLocation(state.program,"u_model"),state.u_view=gl.getUniformLocation(state.program,"u_view"),state.u_projection=gl.getUniformLocation(state.program,"u_projection"),state.u_color=gl.getUniformLocation(state.program,"u_color"),state.u_ambientStrength=gl.getUniformLocation(state.program,"u_ambientStrength"),state.u_diffuseStrength=gl.getUniformLocation(state.program,"u_diffuseStrength"),state.center={rotation:0,axis:vec3.normalize([5,4,3])},state.cube_distance_timer=0,state.cubes=Array.from({length:5}).map(((t,e,a)=>({rotation:e,orbit:2*Math.PI*e/a.length,axis:vec3.normalize([5,e,e-1])}))),state.mouse={x:canvas.width/2,y:canvas.height/2},state.camera={initial:{x:-1,y:-2.2,z:8},x:-1,y:-2.2,z:8},state.theme=document.documentElement.classList.contains("dark")?"dark":"light",state.scrollY=window.scrollY}function update(){const t=.0016,e=canvas.width,a=canvas.height;gl.viewport(0,0,e,a),gl.clearColor(0,0,0,0),gl.clearDepth(1),gl.enable(gl.DEPTH_TEST),gl.depthFunc(gl.LEQUAL),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),gl.useProgram(state.program),gl.bindBuffer(gl.ARRAY_BUFFER,state.vertices),gl.bindBuffer(gl.ARRAY_BUFFER,state.normals),"dark"===state.theme?(gl.uniform4f(state.u_color,.15,.15,.16,1),gl.uniform1f(state.u_ambientStrength,.5),gl.uniform1f(state.u_diffuseStrength,.4)):(gl.uniform4f(state.u_color,1,1,1,1),gl.uniform1f(state.u_ambientStrength,.9),gl.uniform1f(state.u_diffuseStrength,.06));const r=75*Math.PI/180,o=mat4.perspective(r,e/a,.01,1e3);gl.uniformMatrix4fv(state.u_projection,!1,o);const n=state.mouse.x/e,i=state.mouse.y/a*.5-.016*state.scrollY;state.camera.x+=.1*(state.camera.initial.x-state.camera.x-n),state.camera.y+=.2*(state.camera.initial.y-state.camera.y+i);const l=mat4.translate(-state.camera.x,-state.camera.y,-state.camera.z);gl.uniformMatrix4fv(state.u_view,!1,l),state.center.rotation+=1.5*t;const s=mat4.multiply(mat4.scale(1.8,1.8,1.8),mat4.rotate(state.center.axis,state.center.rotation));gl.uniformMatrix4fv(state.u_model,!1,s),gl.drawArrays(gl.TRIANGLES,0,36),state.cube_distance_timer+=8*t;const c=3+.5*Math.sin(state.cube_distance_timer);for(let e of state.cubes){e.rotation+=2.2*t,e.orbit+=1.2*t;const a=Math.cos(e.orbit)*c,r=Math.sin(e.orbit)*c,o=Math.cos(e.orbit)*-c/3,n=mat4.multiply(mat4.rotate(e.axis,e.rotation),mat4.translate(a,r,o));gl.uniformMatrix4fv(state.u_model,!1,n),gl.drawArrays(gl.TRIANGLES,0,36)}mat4.flush(),requestAnimationFrame(update)}document.addEventListener("mousemove",(function(t){state.mouse.x=t.clientX,state.mouse.y=t.clientY})),document.addEventListener("scroll",(function(t){state.scrollY=window.scrollY})),window.addEventListener("resize",(function(){canvas.width=window.innerWidth,canvas.height=window.innerHeight})),canvas.width=window.innerWidth,canvas.height=window.innerHeight,window.onToggleDark=function(t){state.theme=t},init(),requestAnimationFrame(update);