  <!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Write Your Own C++ Unit Testing Library | Jason Liang</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@500;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1691VYRF8G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1691VYRF8G');
    </script>
    <link rel="stylesheet" href="static/tachyons.min.css">
    <link rel="stylesheet" href="static/default-dark.min.css">
    <link rel="stylesheet" href="static/style.css">
    <script src="static/highlight.min.js"></script>
    <script>
      const prefersDark = localStorage.theme === undefined && window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (localStorage.theme === "dark" || prefersDark) {
        document.documentElement.classList.add("dark-mode");
      } else {
        document.documentElement.classList.remove("dark-mode");
      }

      function toggleDark() {
        if (document.documentElement.classList.contains("dark-mode")) {
          document.documentElement.classList.remove("dark-mode");
          localStorage.theme = "light";
          if (window.changeTheme) {
            window.changeTheme("light");
          }
        } else {
          document.documentElement.classList.add("dark-mode");
          localStorage.theme = "dark";
          if (window.changeTheme) {
            window.changeTheme("dark");
          }
        }
      }
    </script>
  </head>
  <body class="bg-near-white near-black dm-bg-near-black dm-near-white mb6">
    <button
      class="
        bg-near-black near-white hover-bg-mid-gray
        dm-bg-near-white dm-near-black dm-hover-bg-moon-gray
        fixed top-0 right-0 z-999
        flex justify-center items-center mr3 mt3
        shadow bn br-pill
      "
      type="button"
      style="width: 2.25rem; height: 2.25rem"
      onclick="toggleDark()"
    >
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style="width: 20px; height: 20px">
        <path fill-rule="evenodd" d="M7.455 2.004a.75.75 0 01.26.77 7 7 0 009.958 7.967.75.75 0 011.067.853A8.5 8.5 0 116.647 1.921a.75.75 0 01.808.083z" clip-rule="evenodd" />
      </svg>
    </button>
    <nav class="tc pv4">
  <a class="b link near-black dm-near-white dim f4" href="/">Jason Liang</a>
</nav>
<article class="prose">
  <time class="gray flex items-center">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style="width: 20px; height: 20px">
      <path fill-rule="evenodd" d="M5.75 2a.75.75 0 01.75.75V4h7V2.75a.75.75 0 011.5 0V4h.25A2.75 2.75 0 0118 6.75v8.5A2.75 2.75 0 0115.25 18H4.75A2.75 2.75 0 012 15.25v-8.5A2.75 2.75 0 014.75 4H5V2.75A.75.75 0 015.75 2zm-1 5.5c-.69 0-1.25.56-1.25 1.25v6.5c0 .69.56 1.25 1.25 1.25h10.5c.69 0 1.25-.56 1.25-1.25v-6.5c0-.69-.56-1.25-1.25-1.25H4.75z" clip-rule="evenodd" />
    </svg>
    <span class="ml1 f6 fw5">
      January 3, 2022    </span>
  </time>
  <h1 class="mt1">Write Your Own C++ Unit Testing Library</h1>
  <div class="lh-copy">
    <p>By abusing the fact that you can run code before <code>main()</code> by putting it in the
constructor of a global variable, you can make a very small, yet serviceable,
unit testing library in C++:</p>
<pre><code class="language-c++">#include "test.h"

TEST(OnePlusOne) { EXPECT(1 + 1 == 2); }
TEST(OnePlusOneFail) { EXPECT(1 + 1 == 3); }

int main() {
    int err_count = run_all_tests();
    return err_count == 0 ? 0 : -1;
}</code></pre>
<p>The output:</p>
<pre><code>[ PASS ] OnePlusOne
[ FAIL ] OnePlusOneFail: 1 + 1 == 3

1 out of 2 tests passed</code></pre>
<h2>Behind The Scenes</h2>
<p><code>test.h</code> takes each <code>TEST()</code> and stores them in a vector of <code>TestCase</code> structs.</p>
<pre><code class="language-c++">struct TestCase {
    const char *name;
    void (*run)(const char *&amp;);
};

static std::vector&lt;TestCase&gt; global_all_tests;</code></pre>
<p>Let's take <code>TEST(OnePlusOne) { EXPECT(1 + 1 == 2); }</code> as an example: The <code>name</code>
for this test case will be set to <code>"OnePlusOne"</code>, and <code>run</code> will become a
pointer to a function that executes <code>EXPECT(1 + 1 == 2)</code> when invoked.
This test case gets added to <code>global_all_tests</code> and the <code>run_all_tests()</code> function
goes through each test case in the vector and calls the <code>run</code> function on each of them.</p>
<p>Here is the implementation of the <code>TEST()</code> and <code>EXCEPT()</code> macros:</p>
<pre><code class="language-c++">#define TEST(name)                                                             \
    void(_test_##name)(const char *&amp;);                                         \
    static void _init_##name() {                                               \
        global_all_tests.push_back({#name, _test_##name});                     \
    }                                                                          \
    struct _struct_##name {                                                    \
        _struct_##name() { _init_##name(); }                                   \
    };                                                                         \
    static _struct_##name _var_##name;                                         \
    void(_test_##name)(const char *&amp;_test_reason)

#define EXPECT(cond)                                                           \
    if (!(cond)) {                                                             \
        _test_reason = #cond;                                                  \
        return;                                                                \
    }</code></pre>
<p>To break this down:</p>
<ol>
<li><code>void(_test_##name)(const char *&amp;);</code> is the function signature for the test case.
The implementation is for the user to fill in, which is why the <code>TEST()</code> macro
ends with the same function, except the body is missing.</li>
<li><code>static void _init_##name() { ... }</code> is a function that will get called before <code>main()</code>.
The function <code>_test_##name</code> is added to <code>global_all_tests</code>.</li>
<li><code>struct _struct_##name { ... };</code> is a type that calls the function above in its
constructor.</li>
<li><code>static _struct_##name _var_##name;</code> actually runs the <code>_init_##name()</code> function
by creating a variable of the type that was written above.</li>
<li><code>void(_test_##name)(const char *&amp;_test_reason)</code> is the actual function for the test.
To check if a test passed, each test function takes a string. The value of the
string passed in will be null, and the <code>EXCEPT()</code> macro sets the string whenever
the test fails. The test passes when the string remains null.</li>
</ol>
<p>That's pretty much it. Create a <code>run_all_tests()</code> and create <code>const char *</code> variable.
Make a loop and pass the variable to each test case. For each test, check if the
variable gets mutated to see if it passed or failed.</p>
<h2>The Full Source Code</h2>
<p>Here is <code>test.h</code> in its entirety. It's only 47 lines.</p>
<pre><code class="language-c++">#pragma once

#include &lt;cstdio&gt;
#include &lt;vector&gt;

struct TestCase {
    const char *name;
    void (*run)(const char *&amp;);
};

static std::vector&lt;TestCase&gt; global_all_tests;

#define TEST(name)                                                             \
    void(_test_##name)(const char *&amp;);                                         \
    static void _init_##name() {                                               \
        global_all_tests.push_back({#name, _test_##name});                     \
    }                                                                          \
    struct _struct_##name {                                                    \
        _struct_##name() { _init_##name(); }                                   \
    };                                                                         \
    static _struct_##name _var_##name;                                         \
    void(_test_##name)(const char *&amp;_test_reason)

#define EXPECT(cond)                                                           \
    if (!(cond)) {                                                             \
        _test_reason = #cond;                                                  \
        return;                                                                \
    }

static int run_all_tests() {
    const char *reason = nullptr;
    int passed = 0;

    for (const auto test : global_all_tests) {
        test.run(reason);
        if (reason) {
            printf("[ FAIL ] %s: %s\n", test.name, reason);
            reason = nullptr;
        } else {
            printf("[ PASS ] %s\n", test.name);
            passed++;
        }
    }

    printf("\n%d out of %u tests passed\n", passed, global_all_tests.size());
    return global_all_tests.size() - passed;
}</code></pre>  </div>
</article>
<script>hljs.highlightAll();</script>
  </body>
  </html>
  <!-- be nice to people -->
  