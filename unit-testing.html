<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
  Write Your Own C&#43;&#43; Unit Testing Library
</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/public/style.css">
  <link rel="stylesheet" href="/public/tachyons.min.css">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-1691VYRF8G"></script>
  <script>
    window.dataLayer = window.dataLayer || []
    function gtag(){dataLayer.push(arguments)}
    gtag('js', new Date())
    gtag('config', 'G-1691VYRF8G')
  </script>
  
  <script>
    function updateTheme() {
      const doc = document.documentElement

      let dark
      if ('theme' in localStorage) {
        dark = localStorage.theme === 'dark'
      } else {
        dark = window.matchMedia('(prefers-color-scheme: dark)').matches
      }

      if (dark) {
        doc.classList.add('dark')
      } else {
        doc.classList.remove('dark')
      }

      if (typeof onUpdateTheme === 'function') {
        onUpdateTheme()
      }
    }

    function toggleTheme() {
      const doc = document.documentElement
      localStorage.theme = doc.classList.contains('dark') ? 'light' : 'dark'
      updateTheme()
    }

    updateTheme()
  </script>
</head>
<body>
  <button class="theme-button fixed top-0 right-0 z-999 flex mt3 mr3 bn br-pill pa2" onclick="toggleTheme()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="20" height="20">
      <path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.06l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.06 1.06a.75.75 0 001.06 1.06l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.06 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.06a.75.75 0 10-1.061 1.06l1.06 1.06z" />
    </svg>
  </button>
  
  <div class="mw7 center ph3">
    <header class="pt4">
      <a class="harsh fw7 f3 link" href="/">Jason Liang</a>
    </header>
    <article class="prose">
      <time>January 3, 2022</time>
      <h1>Write Your Own C&#43;&#43; Unit Testing Library</h1>
      <p>By abusing the fact that you can run code before <code>main()</code> by putting it in the
constructor of a global variable, you can make a very small, yet serviceable,
unit testing library in C++:</p>

<pre><code class="language-c++">#include &quot;test.h&quot;

TEST(OnePlusOne) { EXPECT(1 + 1 == 2); }
TEST(OnePlusOneFail) { EXPECT(1 + 1 == 3); }

int main() {
    int err_count = run_all_tests();
    return err_count == 0 ? 0 : -1;
}
</code></pre>

<p>The output:</p>

<pre><code>[ PASS ] OnePlusOne
[ FAIL ] OnePlusOneFail: 1 + 1 == 3

1 out of 2 tests passed
</code></pre>

<h2 id="behind-the-scenes">Behind The Scenes</h2>

<p><code>test.h</code> takes each <code>TEST()</code> and stores them in a vector of <code>TestCase</code> structs.</p>

<pre><code class="language-c++">struct TestCase {
    const char *name;
    void (*run)(const char *&amp;);
};

static std::vector&lt;TestCase&gt; global_all_tests;
</code></pre>

<p>Let&rsquo;s take <code>TEST(OnePlusOne) { EXPECT(1 + 1 == 2); }</code> as an example: The <code>name</code>
for this test case will be set to <code>&quot;OnePlusOne&quot;</code>, and <code>run</code> will become a
pointer to a function that executes <code>EXPECT(1 + 1 == 2)</code> when invoked.
This test case gets added to <code>global_all_tests</code> and the <code>run_all_tests()</code> function
goes through each test case in the vector and calls the <code>run</code> function on each of them.</p>

<p>Here is the implementation of the <code>TEST()</code> and <code>EXCEPT()</code> macros:</p>

<pre><code class="language-c++">#define TEST(name)                                                             \
    void(_test_##name)(const char *&amp;);                                         \
    static void _init_##name() {                                               \
        global_all_tests.push_back({#name, _test_##name});                     \
    }                                                                          \
    struct _struct_##name {                                                    \
        _struct_##name() { _init_##name(); }                                   \
    };                                                                         \
    static _struct_##name _var_##name;                                         \
    void(_test_##name)(const char *&amp;_test_reason)

#define EXPECT(cond)                                                           \
    if (!(cond)) {                                                             \
        _test_reason = #cond;                                                  \
        return;                                                                \
    }
</code></pre>

<p>To break this down:</p>

<ol>
<li><code>void(_test_##name)(const char *&amp;);</code> is the function signature for the test case.
 The implementation is for the user to fill in, which is why the <code>TEST()</code> macro
 ends with the same function, except the body is missing.</li>
<li><code>static void _init_##name() { ... }</code> is a function that will get called before <code>main()</code>.
 The function <code>_test_##name</code> is added to <code>global_all_tests</code>.</li>
<li><code>struct _struct_##name { ... };</code> is a type that calls the function above in its
 constructor.</li>
<li><code>static _struct_##name _var_##name;</code> actually runs the <code>_init_##name()</code> function
 by creating a variable of the type that was written above.</li>
<li><code>void(_test_##name)(const char *&amp;_test_reason)</code> is the actual function for the test.
 To check if a test passed, each test function takes a string. The value of the
 string passed in will be null, and the <code>EXCEPT()</code> macro sets the string whenever
 the test fails. The test passes when the string remains null.</li>
</ol>

<p>That&rsquo;s pretty much it. Create a <code>run_all_tests()</code> and create <code>const char *</code> variable.
Make a loop and pass the variable to each test case. For each test, check if the
variable gets mutated to see if it passed or failed.</p>

<h2 id="the-full-source-code">The Full Source Code</h2>

<p>Here is <code>test.h</code> in its entirety. It&rsquo;s only 47 lines.</p>

<pre><code class="language-c++">#pragma once

#include &lt;cstdio&gt;
#include &lt;vector&gt;

struct TestCase {
    const char *name;
    void (*run)(const char *&amp;);
};

static std::vector&lt;TestCase&gt; global_all_tests;

#define TEST(name)                                                             \
    void(_test_##name)(const char *&amp;);                                         \
    static void _init_##name() {                                               \
        global_all_tests.push_back({#name, _test_##name});                     \
    }                                                                          \
    struct _struct_##name {                                                    \
        _struct_##name() { _init_##name(); }                                   \
    };                                                                         \
    static _struct_##name _var_##name;                                         \
    void(_test_##name)(const char *&amp;_test_reason)

#define EXPECT(cond)                                                           \
    if (!(cond)) {                                                             \
        _test_reason = #cond;                                                  \
        return;                                                                \
    }

static int run_all_tests() {
    const char *reason = nullptr;
    int passed = 0;

    for (const auto test : global_all_tests) {
        test.run(reason);
        if (reason) {
            printf(&quot;[ FAIL ] %s: %s\n&quot;, test.name, reason);
            reason = nullptr;
        } else {
            printf(&quot;[ PASS ] %s\n&quot;, test.name);
            passed++;
        }
    }

    printf(&quot;\n%d out of %u tests passed\n&quot;, passed, global_all_tests.size());
    return global_all_tests.size() - passed;
}
</code></pre>

    </article>
  </div>

  
  <script src="/public/hljs/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>

  
</body>
</html>