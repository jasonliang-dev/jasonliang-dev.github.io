<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
  A Tiny OpenGL 2D Batch Renderer
</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/public/style.css">
  <link rel="stylesheet" href="/public/tachyons.min.css">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-1691VYRF8G"></script>
  <script>
    window.dataLayer = window.dataLayer || []
    function gtag(){dataLayer.push(arguments)}
    gtag('js', new Date())
    gtag('config', 'G-1691VYRF8G')
  </script>
  
  <script>
    function updateTheme() {
      const doc = document.documentElement

      let dark
      if ('theme' in localStorage) {
        dark = localStorage.theme === 'dark'
      } else {
        dark = window.matchMedia('(prefers-color-scheme: dark)').matches
      }

      if (dark) {
        doc.classList.add('dark')
      } else {
        doc.classList.remove('dark')
      }

      if (typeof onUpdateTheme === 'function') {
        onUpdateTheme()
      }
    }

    function toggleTheme() {
      const doc = document.documentElement
      localStorage.theme = doc.classList.contains('dark') ? 'light' : 'dark'
      updateTheme()
    }

    updateTheme()
  </script>
</head>
<body>
  <button class="theme-button fixed top-0 right-0 z-999 flex mt3 mr3 bn br-pill pa2" onclick="toggleTheme()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="20" height="20">
      <path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.06l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.06 1.06a.75.75 0 001.06 1.06l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.06 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.06a.75.75 0 10-1.061 1.06l1.06 1.06z" />
    </svg>
  </button>
  
  <div class="mw7 center ph3">
    <header class="pt4">
      <a class="harsh fw7 f3 link" href="/">Jason Liang</a>
    </header>
    <article class="prose">
      <time>January 4, 2022</time>
      <h1>A Tiny OpenGL 2D Batch Renderer</h1>
      <p><img src="/public/batch-rendering/aliens.png" alt="A grid of 2D sprites" /></p>

<p>If you rather read code than words, the source is available
on <a href="https://github.com/jasonliang-dev/tiny-batch-renderer" target="_blank">GitHub</a>.</p>

<p>This article describes a small batch renderer written in C using modern OpenGL.
The goal is to write the minimum amount to code to reduce draw calls. It&rsquo;s not
going to be the fastest or the most efficient implementation, but it&rsquo;s probably
one of the smallest, for learning purposes.</p>

<p>Below is an example of how the batch renderer can be used to draw a grid of sprites
representing aliens:</p>

<pre><code class="language-c">typedef struct {
  // position
  float px, py;
  // texcoords
  float tx, ty, tw, th;
} Alien;

void draw_alien(BatchRenderer *renderer, Texture tex, Alien a) {
  r_texture(renderer, tex.id);

  float x1 = a.px;
  float y1 = a.py;
  float x2 = a.px + 48;
  float y2 = a.py + 48;

  float u1 = a.tx / tex.width;
  float v1 = a.ty / tex.height;
  float u2 = (a.tx + a.tw) / tex.width;
  float v2 = (a.ty + a.th) / tex.height;

  r_push_vertex(renderer, x1, y1, u1, v1);
  r_push_vertex(renderer, x2, y2, u2, v2);
  r_push_vertex(renderer, x1, y2, u1, v2);

  r_push_vertex(renderer, x1, y1, u1, v1);
  r_push_vertex(renderer, x2, y1, u2, v1);
  r_push_vertex(renderer, x2, y2, u2, v2);
}

int main(void) {
  // ...
  BatchRenderer renderer = create_renderer(6000);
  Texture tex_aliens = create_texture(&quot;aliens.png&quot;);

  struct {
    float x, y, w, h;
  } alien_uvs[] = {
    {2, 2, 24, 24},   {58, 2, 24, 24}, {114, 2, 24, 24},
    {170, 2, 24, 24}, {2, 30, 24, 24},
  };

  while (!glfwWindowShouldClose(window)) {
    // ...
    r_mvp(&amp;renderer, mat_ortho(0, (float)width, (float)height, 0, -1.0f, 1.0f));

    float y = 0;
    for (int i = 0; i &lt; 15; i++) {
      float x = 0;
      for (int j = 0; j &lt; 4; j++) {
        for (int k = 0; k &lt; 5; k++) {
          Alien ch = {
            .px = x,
            .py = y,
            .tx = alien_uvs[k].x,
            .ty = alien_uvs[k].y,
            .tw = alien_uvs[k].w,
            .th = alien_uvs[k].h,
          };
          draw_alien(&amp;renderer, tex_aliens, ch);
          x += 48;
        }
      }
      y += 48;
    }

    r_flush(&amp;renderer);
    // ...
  }
}
</code></pre>

<p>This (incomplete) program produces the image at the top of this article.</p>

<h2 id="how-batch-rendering-works">How Batch Rendering Works</h2>

<p>Without batch rendering, this is how drawing a grid of aliens might look like:</p>

<pre><code class="language-c">void draw_alien() {
  // ...
  glBindVertexArray(vao);
  glDrawArrays(GL_TRIANGLES, 0, 6); // or glDrawElements()
}

int main() {
  while (...) {
    for (...) {
      draw_alien();
    }
  }
}
</code></pre>

<p>Each alien performs a draw call. Six vertices are drawn from the vertex array,
which probably describes two triangles that make up a single quad.</p>

<p>A batch renderer avoids making draw calls by setting up a large dynamic vertex
buffer object, where vertex data gets written to a buffer every frame and then
the buffer gets used in a single draw call. The data itself may contain
multiple quads with different vertex positions, texture coordinates, and
perhaps tint colour.</p>

<p>A draw call should be performed:</p>

<ul>
<li>When the vertex buffer reaches its capacity</li>
<li>When any uniform values need to change</li>
<li>When it&rsquo;s the end of the frame</li>
</ul>

<p>After submitting a draw call, the vertex buffer is &ldquo;flushed&rdquo; to set up for the
next draw call.</p>

<pre><code class="language-c">void draw_alien() {
  // nothing is actually drawn at this stage.
  // data is just being written to a buffer
  r_push_vertex(...); // x6
}

int main() {
  while (...) {
    for (...) {
      draw_alien();
    }
    r_flush(); // this is where glDrawArrays actually gets called
  }
}
</code></pre>

<p>In summary, instead of naively making a draw call for each alien:</p>

<p><img src="/public/batch-rendering/draw1.png" alt="" /></p>

<p><code>draw_alien()</code> writes to a buffer, and then <code>r_flush()</code> performs a single draw
call.</p>

<p><img src="/public/batch-rendering/draw2.png" alt="" /></p>

<p>By reducing the number of draw calls, we can increase the performance of our
program.</p>

<h2 id="implementation">Implementation</h2>

<p>The <code>BatchRenderer</code> struct contains a shader program <code>shader</code>, a vertex array
object <code>vao</code>, a vertex buffer object <code>vbo</code>, an array of vertices in CPU memory
<code>vertices</code>, and values that get bound to uniforms <code>texture</code> and <code>mvp</code>.</p>

<pre><code class="language-c">typedef struct { float cols[4][4]; } Matrix;
typedef struct { float position[2]; float texcoord[2]; } Vertex;

typedef struct {
  GLuint shader;

  // vertex buffer data
  GLuint vao;
  GLuint vbo;
  int vertex_count;
  int vertex_capacity;
  Vertex *vertices;

  // uniform values
  GLuint texture;
  Matrix mvp;
} BatchRenderer;
</code></pre>

<p>The <code>vertices</code> buffer is needed to write vertex data somewhere in CPU memory,
and the vertex buffer object <code>vbo</code> is needed to read vertex data in GPU memory.
To avoid confusion, I&rsquo;ll be referring to the vertex buffer object as the GPU
vertex buffer or VBO, and the array of vertices in CPU memory as the CPU vertex
buffer.</p>

<p>The following function initializes a batch renderer with a given capacity for
the CPU vertex buffer:</p>

<pre><code class="language-c">BatchRenderer create_renderer(int vertex_capacity) {
  GLuint vao;
  glGenVertexArrays(1, &amp;vao);
  glBindVertexArray(vao);

  // create the dynamic vertex buffer
  GLuint vbo;
  glGenBuffers(1, &amp;vbo);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * vertex_capacity, NULL,
               GL_DYNAMIC_DRAW);

  glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                        (void *)offsetof(Vertex, position));

  glEnableVertexAttribArray(1);
  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                        (void *)offsetof(Vertex, texcoord));

  const char *vertex =
      &quot;#version 330 core\n&quot;
      &quot;layout(location=0) in vec2 a_position;\n&quot;
      &quot;layout(location=1) in vec2 a_texindex;\n&quot;
      &quot;out vec2 v_texindex;\n&quot;
      &quot;uniform mat4 u_mvp;\n&quot;
      &quot;void main() {\n&quot;
      &quot;    gl_Position = u_mvp * vec4(a_position, 0.0, 1.0);\n&quot;
      &quot;    v_texindex = a_texindex;\n&quot;
      &quot;}\n&quot;;

  const char *fragment = &quot;#version 330 core\n&quot;
                         &quot;in vec2 v_texindex;\n&quot;
                         &quot;out vec4 f_color;\n&quot;
                         &quot;uniform sampler2D u_texture;\n&quot;
                         &quot;void main() {\n&quot;
                         &quot;    f_color = texture(u_texture, v_texindex);\n&quot;
                         &quot;}\n&quot;;

  GLuint program = load_shader(vertex, fragment);

  return (BatchRenderer){
    .shader = program,
    .vao = vao,
    .vbo = vbo,
    .vertex_count = 0,
    .vertex_capacity = vertex_capacity,
    .vertices = malloc(sizeof(Vertex) * vertex_capacity),
    .texture = 0,
    .mvp = {0},
  };
}
</code></pre>

<p>The main takeaway is the call to <code>glBufferData()</code>. The usage pattern for the
GPU vertex buffer is <code>GL_DYNAMIC_DRAW</code> instead of something like
<code>GL_STATIC_DRAW</code>.  This allows us to change the contents of the GPU vertex
buffer in the future using the <code>glBufferSubData()</code> function. The data parameter
is <code>NULL</code>, which means the VBO data living in VRAM is uninitialized.</p>

<p>I won&rsquo;t go into detail about the <code>load_shader()</code> function since it&rsquo;s nothing
special. The function returns the result of <code>glCreateProgram()</code> after compiling
the given vertex and fragment shaders. The shaders themselves consist of simple
GLSL that would be expected from a basic 2D renderer.</p>

<p>The memory allocated for <code>vertices</code> should be the same size as the VBO, which
is <code>sizeof(Vertex) * vertex_capacity</code>. This array of vertices living in CPU
memory is the buffer that will be written to whenever something needs to be
drawn, but it should not be mutated directly. <code>r_push_vertex()</code> should be used
instead, which does some housekeeping by incrementing <code>vertex_count</code> by one and
it checks when the CPU vertex buffer is at capacity.</p>

<pre><code class="language-c">void r_push_vertex(BatchRenderer *renderer, float x, float y, float u,
                   float v) {
  if (renderer-&gt;vertex_count == renderer-&gt;vertex_capacity) {
    r_flush(renderer);
  }

  renderer-&gt;vertices[renderer-&gt;vertex_count++] = (Vertex){
    .position = {x, y},
    .texcoord = {u, v},
  };
}
</code></pre>

<p>When the CPU vertex buffer reaches its capacity, then we have no more room to
add another vertex. The solution is to submit a draw call and empty the CPU
vertex buffer with <code>r_flush()</code>.</p>

<pre><code class="language-c">void r_flush(BatchRenderer *renderer) {
  if (renderer-&gt;vertex_count == 0) {
    return;
  }

  glUseProgram(renderer-&gt;shader);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, renderer-&gt;texture);

  glUniform1i(glGetUniformLocation(renderer-&gt;shader, &quot;u_texture&quot;), 0);
  glUniformMatrix4fv(glGetUniformLocation(renderer-&gt;shader, &quot;u_mvp&quot;), 1,
                     GL_FALSE, renderer-&gt;mvp.cols[0]);

  glBindBuffer(GL_ARRAY_BUFFER, renderer-&gt;vbo);
  glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vertex) * renderer-&gt;vertex_count,
                  renderer-&gt;vertices);

  glBindVertexArray(renderer-&gt;vao);
  glDrawArrays(GL_TRIANGLES, 0, renderer-&gt;vertex_count);

  renderer-&gt;vertex_count = 0;
}
</code></pre>

<p>This is where <code>glBufferSubData()</code> comes into play. <code>glBufferSubData()</code> is analogous
to <code>memcpy()</code> except it copies from CPU memory into GPU memory instead of
exclusively working in CPU memory. <code>0</code> is the offset where data is copied to
(0 being the start of the VBO data). <code>sizeof(Vertex) * renderer-&gt;vertex_count</code> is
the number of bytes to copy. <code>renderer-&gt;vertices</code> is the data to copy from.</p>

<p>After binding the uniform values, and copying the CPU vertex buffer data to GPU memory,
a draw call is made with <code>glDrawArrays()</code>, and <code>vertex_count</code> is set to 0 to set up
for the next call to <code>r_flush</code>.</p>

<p>Almost done. There&rsquo;s one case that has to be handled: whenever any uniform needs to change,
the CPU vertex buffer needs to be flushed before setting the uniform. The following
functions are created just for these cases:</p>

<pre><code class="language-c">void r_texture(BatchRenderer *renderer, GLuint id) {
  if (renderer-&gt;texture != id) {
    r_flush(renderer);
    renderer-&gt;texture = id;
  }
}

void r_mvp(BatchRenderer *renderer, Matrix mat) {
  if (memcmp(&amp;renderer-&gt;mvp.cols, &amp;mat.cols, sizeof(Matrix)) != 0) {
    r_flush(renderer);
    renderer-&gt;mvp = mat;
  }
}
</code></pre>

<p>That&rsquo;s it! To use the renderer, call <code>create_renderer()</code> during program initialization,
<code>r_push_vertex()</code> when drawing in the main render loop, and <code>r_flush()</code> at the
end of each frame.</p>

<p>The source code for the entire program is available on
<a href="https://github.com/jasonliang-dev/tiny-batch-renderer" target="_blank">GitHub</a>.</p>

<h2 id="improvements">Improvements</h2>

<p>Here is a list of changes that can be made to this renderer to improve its
performance and efficiency:</p>

<ul>
<li>Store uniform locations to avoid <code>glGetUniformLocation()</code> in <code>r_flush()</code>.</li>
<li>Create an index buffer to improve efficiency and memory usage when exclusively
drawing quads. Drawing a quad would need four calls to <code>r_push_vertex()</code> instead of six.</li>
<li>Create multiple buffers and group them based on texture to minimize state changes.</li>
</ul>

    </article>
  </div>

  
  <script src="/public/hljs/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>

  
</body>
</html>